Â¡Claro que sÃ­\! Vamos a reiniciar el proyecto. Esta es la guÃ­a definitiva **"End-to-End"** para crear una API profesional con TypeScript, Inversify (SOLID) y SQLite en memoria.

No necesitas nada anterior. AquÃ­ estÃ¡ todo, paso a paso.

-----

### 1\. InicializaciÃ³n y Dependencias

Abre tu terminal y ejecuta estos comandos en orden:

```bash
# 1. Crear carpeta y entrar
mkdir api-solid-sqlite
cd api-solid-sqlite

# 2. Iniciar Node
npm init -y

# 3. Instalar dependencias CORE
npm install express inversify inversify-express-utils reflect-metadata better-sqlite3 class-validator class-transformer jsonwebtoken bcryptjs dotenv

# 4. Instalar dependencias de DESARROLLO (Tipos y herramientas)
npm install -D typescript ts-node nodemon @types/node @types/express @types/better-sqlite3 @types/jsonwebtoken @types/bcryptjs

# 5. Crear archivo de configuraciÃ³n TypeScript
npx tsc --init
```

-----

### 2\. ConfiguraciÃ³n Esencial (`tsconfig.json`)

Edita el archivo `tsconfig.json` generado. **Debes** asegurarte de que estas opciones estÃ©n asÃ­ para que la InyecciÃ³n de Dependencias funcione:

```json
{
  "compilerOptions": {
    "target": "ES2018",
    "module": "commonjs",
    "lib": ["es6", "dom"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,  /* OBLIGATORIO PARA INVERSIFY */
    "emitDecoratorMetadata": true,   /* OBLIGATORIO PARA INVERSIFY */
    "skipLibCheck": true
  },
  "exclude": ["node_modules"]
}
```

-----

### 3\. Estructura del Proyecto

Crea manualmente esta estructura de carpetas dentro de tu proyecto:

```text
src/
â”œâ”€â”€ config/             # Tipos para DI y configuraciÃ³n de variables
â”œâ”€â”€ controllers/        # Controladores HTTP
â”œâ”€â”€ domain/             # Entidades y Contratos (Interfaces)
â”‚   â”œâ”€â”€ entities/
â”‚   â””â”€â”€ interfaces/
â”œâ”€â”€ dtos/               # Objetos de Transferencia de Datos (ValidaciÃ³n)
â”œâ”€â”€ infrastructure/     # ImplementaciÃ³n concreta (DB, Repositorios)
â”‚   â”œâ”€â”€ db/
â”‚   â””â”€â”€ repositories/
â”œâ”€â”€ services/           # LÃ³gica de Negocio
â”œâ”€â”€ middlewares/        # Validadores
â”œâ”€â”€ container.ts        # Contenedor de InyecciÃ³n de Dependencias
â””â”€â”€ index.ts            # Punto de entrada
```

-----

### 4\. CÃ³digo Fuente (Paso a Paso)

#### A. ConfiguraciÃ³n (`src/config/types.ts`)

Definimos los identificadores Ãºnicos para nuestras dependencias.

```typescript
// src/config/types.ts
export const TYPES = {
    UserRepository: Symbol.for("UserRepository"),
    AuthService: Symbol.for("AuthService")
};
```

#### B. Capa de Dominio (Entidades e Interfaces)

AquÃ­ definimos **QUÃ‰** son nuestros datos y **QUÃ‰** operaciones necesitamos, sin importar **CÃ“MO** se guarden.

**Entidad:**

```typescript
// src/domain/entities/User.ts
// [SRP]: Responsabilidad Ãšnica. Solo define la estructura del usuario.
export class User {
    constructor(
        public id: string,
        public email: string,
        public password: string,
        public name: string
    ) {}
}
```

**Interfaz del Repositorio:**

```typescript
// src/domain/interfaces/IUserRepository.ts
import { User } from "../entities/User";

// [ISP]: SegregaciÃ³n de Interfaces. Definimos un contrato claro.
// [DIP]: InversiÃ³n de Dependencias. El servicio dependerÃ¡ de esto, no de SQLite.
export interface IUserRepository {
    findByEmail(email: string): Promise<User | null>;
    create(user: User): Promise<User>;
}
```

#### C. Capa de Infraestructura (Base de Datos y Repositorio)

**ConexiÃ³n a SQLite:**

```typescript
// src/infrastructure/db/database.ts
import Database from 'better-sqlite3';

// Creamos la BD en memoria RAM
const db = new Database(':memory:');

// Inicializamos la tabla al arrancar
db.exec(`
  CREATE TABLE IF NOT EXISTS users (
    id TEXT PRIMARY KEY,
    email TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL,
    name TEXT NOT NULL
  )
`);

console.log("ðŸ’¾ Base de datos SQLite en memoria lista.");

export default db;
```

**ImplementaciÃ³n del Repositorio:**

```typescript
// src/infrastructure/repositories/SQLiteUserRepository.ts
import { injectable } from "inversify";
import { IUserRepository } from "../../domain/interfaces/IUserRepository";
import { User } from "../../domain/entities/User";
import db from "../db/database";

// [LSP]: SustituciÃ³n de Liskov. Esta clase cumple el contrato IUserRepository.
@injectable()
export class SQLiteUserRepository implements IUserRepository {

    async findByEmail(email: string): Promise<User | null> {
        const stmt = db.prepare('SELECT * FROM users WHERE email = ?');
        const row = stmt.get(email) as any;

        if (!row) return null;
        return new User(row.id, row.email, row.password, row.name);
    }

    async create(user: User): Promise<User> {
        const stmt = db.prepare('INSERT INTO users (id, email, password, name) VALUES (?, ?, ?, ?)');
        try {
            stmt.run(user.id, user.email, user.password, user.name);
            return user;
        } catch (error) {
            throw new Error("Error al crear usuario en BD");
        }
    }
}
```

#### D. Capa de AplicaciÃ³n (DTOs y Servicios)

**DTO (Data Transfer Object):**

```typescript
// src/dtos/RegisterDto.ts
import { IsEmail, IsString, MinLength } from "class-validator";

// [SRP]: Solo valida datos de entrada.
export class RegisterDto {
    @IsEmail({}, { message: "Email invÃ¡lido" })
    email!: string;

    @IsString()
    @MinLength(6, { message: "La contraseÃ±a debe tener mÃ­nimo 6 caracteres" })
    password!: string;

    @IsString()
    @MinLength(2)
    name!: string;
}
```

**Servicio de AutenticaciÃ³n:**

```typescript
// src/services/AuthService.ts
import { injectable, inject } from "inversify";
import { TYPES } from "../config/types";
import { IUserRepository } from "../domain/interfaces/IUserRepository";
import { RegisterDto } from "../dtos/RegisterDto";
import { User } from "../domain/entities/User";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import { v4 as uuidv4 } from "uuid"; // (Nota: puedes usar crypto.randomUUID si no quieres instalar uuid)

@injectable()
export class AuthService {
    
    // [DIP]: Inyectamos la Interfaz (AbstracciÃ³n), no la clase SQLiteUserRepository.
    constructor(
        @inject(TYPES.UserRepository) private userRepo: IUserRepository
    ) {}

    async register(dto: RegisterDto): Promise<{ token: string; user: any }> {
        // 1. Verificar si existe
        const existing = await this.userRepo.findByEmail(dto.email);
        if (existing) throw new Error("El usuario ya existe");

        // 2. Hash password
        const hashedPassword = await bcrypt.hash(dto.password, 10);

        // 3. Crear entidad
        // Nota: Para simplificar usamos Date.now como ID, en prod usar UUID
        const newUser = new User(
            Date.now().toString(), 
            dto.email, 
            hashedPassword, 
            dto.name
        );

        // 4. Guardar
        await this.userRepo.create(newUser);

        // 5. Generar JWT
        const token = jwt.sign(
            { id: newUser.id, email: newUser.email }, 
            "TU_SECRETO_JWT", 
            { expiresIn: "1h" }
        );

        // Retornamos token y datos del usuario (sin password)
        const { password, ...userWithoutPass } = newUser;
        return { token, user: userWithoutPass };
    }
}
```

#### E. Capa de PresentaciÃ³n (Middleware y Controlador)

**Middleware de ValidaciÃ³n:**

```typescript
// src/middlewares/ValidateDto.ts
import { plainToInstance } from "class-transformer";
import { validate } from "class-validator";
import { Request, Response, NextFunction } from "express";

export function validateDto(dtoClass: any) {
    return async (req: Request, res: Response, next: NextFunction) => {
        // Convierte el JSON body a una Instancia de la clase DTO
        const dtoObj = plainToInstance(dtoClass, req.body);
        const errors = await validate(dtoObj);

        if (errors.length > 0) {
            const messages = errors.map(err => 
                Object.values(err.constraints || {}).join(", ")
            );
            res.status(400).json({ errors: messages });
            return;
        }
        next();
    };
}
```

**Controlador:**

```typescript
// src/controllers/AuthController.ts
import { controller, httpPost } from "inversify-express-utils";
import { inject } from "inversify";
import { Request, Response } from "express";
import { TYPES } from "../config/types";
import { AuthService } from "../services/AuthService";
import { validateDto } from "../middlewares/ValidateDto";
import { RegisterDto } from "../dtos/RegisterDto";

@controller("/auth")
export class AuthController {
    
    constructor(@inject(TYPES.AuthService) private authService: AuthService) {}

    @httpPost("/register", validateDto(RegisterDto))
    async register(req: Request, res: Response) {
        try {
            const result = await this.authService.register(req.body);
            res.status(201).json(result);
        } catch (error: any) {
            res.status(400).json({ error: error.message });
        }
    }
}
```

#### F. El Contenedor de InyecciÃ³n (`src/container.ts`)

```typescript
// src/container.ts
import { Container } from "inversify";
import { TYPES } from "./config/types";

// Interfaces
import { IUserRepository } from "./domain/interfaces/IUserRepository";

// Implementaciones
import { SQLiteUserRepository } from "./infrastructure/repositories/SQLiteUserRepository";
import { AuthService } from "./services/AuthService";

// Controladores (Importante importarlos aquÃ­ para que se registren)
import "./controllers/AuthController";

const container = new Container();

// [Binding]: AquÃ­ decimos "Cuando alguien pida IUserRepository, dale SQLiteUserRepository"
// inSingletonScope = Una sola instancia de la DB para toda la app.
container.bind<IUserRepository>(TYPES.UserRepository).to(SQLiteUserRepository).inSingletonScope();
container.bind<AuthService>(TYPES.AuthService).to(AuthService).inSingletonScope();

export { container };
```

#### G. Punto de Entrada (`src/index.ts`)

```typescript
// src/index.ts
import "reflect-metadata"; // [IMPORTANTE]: DEBE SER LA PRIMERA LÃNEA
import { InversifyExpressServer } from "inversify-express-utils";
import { container } from "./container";
import express from "express";

// Crear servidor con el contenedor configurado
const server = new InversifyExpressServer(container);

server.setConfig((app) => {
    app.use(express.json()); // Parsear JSON
    // AquÃ­ puedes agregar cors, helmet, morgan, etc.
});

const app = server.build();
const PORT = 3000;

app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor corriendo en http://localhost:${PORT}`);
});
```

-----

### 5\. Ejecutar y Probar

1.  Abre `package.json` y aÃ±ade el script:

    ```json
    "scripts": {
      "dev": "nodemon src/index.ts"
    }
    ```

2.  Ejecuta en la terminal:

    ```bash
    npm run dev
    ```

3.  **Probar con cURL o Postman:**

    **PeticiÃ³n Exitosa:**

    ```bash
    curl -X POST http://localhost:3000/auth/register \
      -H "Content-Type: application/json" \
      -d '{"email": "test@example.com", "password": "securePassword123", "name": "Gemini User"}'
    ```

    **PeticiÃ³n con Error (ValidaciÃ³n):**

    ```bash
    curl -X POST http://localhost:3000/auth/register \
      -H "Content-Type: application/json" \
      -d '{"email": "bad-email", "password": "123", "name": "A"}'
    ```

Â¡Listo\! Tienes una arquitectura limpia, escalable, con base de datos SQL en memoria y validaciones robustas. Si ahora quisieras cambiar a PostgreSQL, **solo tendrÃ­as que crear un archivo `PostgresUserRepository.ts` e implementar la interfaz.**

Â¿Te gustarÃ­a que agreguemos un endpoint `GET /profile` que requiera el Token JWT para acceder?